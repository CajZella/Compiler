# 符号表
## 关键问题
*来自《编译技术》课本*
1. 编译程序遍的数目
   1. 多遍扫描在词法分析阶段将标识符填入符号表，标识符的其他属性在语义分析和代码生成阶段填入
   2. 单遍扫描仅仅在语义分析和代码生成部分需要与符号表打交道
2. SysY是分程序结构的语言，在符号表上需执行插入、查表、定位和重定位操作
   1. 查表是在程序的可执行语句部分读到标识符时，需要判断该标识符是否已经声明：当前所在程序单元 -> **直接外层**符号表
   2. 定位是在分程序的入口建立一个新的子表
   3. 重定位是在分程序的出口删除已处理完的分程序的标识符的子表
   4. 定位与重定位操作的工作方式和栈的压入和弹出操作很像。
3. 符号表的内容除了名字外，还需要考虑的特性信息
4. 符号表的组织方式
   1. 平均查找长度-> 散列表 HashMap O(1)
   2. 散列符号表的栈式实现
5. 符号名存储方法
   1. string

注：
1. SysY文法作为C语言的子集，先引用函数再声明函数是不合法的，如下：
```
void func1(){
   func2();
   return;
}
void func2(){
   return;
}
```

2. 变量名和函数名可以相同，注意equals
## 回顾整体架构
我打算通过一遍扫描生成ir中间代码，在语义分析和中间代码生成阶段来处理符号表。

## 符号表内容
每条符号表记录包含标识符`ident`、类型`type`（LLVM IR 中的变量类型）、初始值`initial`、是否为常量`isConst`, 标识符所在行号`line`。

## 符号表的组织方式
为了便于查找，我使用`HashMap<String, Symbol>`存储，记录该层符号表的直接外层符号表`parent`，在查表时若需要检索直接外层符号表则检索`parent`，定位创建子表时记录其`parent`，重定位则返回`parent`。

## 静态内部类
在Parser中，考虑到后续可能对不同类型的语法成分进行一些处理，为每种语法成分单独写一个类并集成gElement抽象类，但太多的类增加了创建和管理的复杂度，在符号表的处理过程中，我借鉴meowcompiler的做法，设置静态内部类。

## 符号表的操作
1. 定位
   1. 在进入分程序的入口时，创建一个新的子表，将其`parent`设置为当前符号表，将当前符号表设置为新的子表。（初始表的`parent`是`null`）
      ```java
        public void locate() {
            currentTable = new SymbolTable(currentTable);
        }
        ```
2. 查表分为声明时的查表和使用时的查表
   1. 声明时仅需查找当前层符号表
   2. 使用时需递归查找当前层及直接外层符号表
3. 插入
   1. 插入当前层符号表
4. 重定位
   1. 在分程序的出口时，将当前符号表设置为其`parent`。
      ```java
        public void relocate() {
            currentTable = currentTable.parent;
        }
        ```
## 符号表的作用
1. 检查对所生命的实体的引用是否正确
2. 利用已声明实体的特性信息，为给定的源程序生成正确的目标代码
## no title
1. 目前我希望在语义分析阶段处理一次符号表的基本信息，ir生成时能重新访问这张符号表。但是我之前写的符号表是一次性访问的，我现在需要增加一个操作，即在ir生成阶段，symbolTable记录当前scope的符号表，当退出当前scope时，我需要获取symbolTable的下一张符号表。我希望实现`LinkedNode` 和 `LinkedList` 链表结构。`SymbolTable`就可以继承`LinkedNode`从而通过`symbolTable.next()`方法实现。
2. 在数组定义部分，希望确定数组每个维度的大小，需要写一个exp计算。